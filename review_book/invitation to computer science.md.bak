讀書報告：電腦科學入門


Invitation to Computer Science https://www.cengage.co.uk/books/9781337561914/
這本書是美國大學的電腦科學的入門課程教科書，程度較淺，覆蓋極廣。由計算機歷史開始講，講到演算法algorithm設計、電腦硬件架構、軟件架構和開發周期、互聯網的結構、電腦科學的應用、計算模型、圖靈機和電腦極限、人工智能。由深入淺，大包圍了電腦相關的各種知識。

這本可謂是教科書的典範。除非你異常地想動一動腦筋挑戰自己，否則你可以完全忽略課文中和課文後的問題集而不影響閱讀體驗。當然也沒有甚麼狗屎垃圾「課堂內容的一部份在練習題當中」，必須的知識全都包含在課文裏面。

# 計算機歷史
現代電腦發展史離不開軍事用途。但更早的是在1900年代。當時美國的移民潮導致人口急速倍增(筆者為地理學專業，有修過美國移民史)，在最高峰的1900–1910年間，有800萬的新增移民人口。而在更闊的時間點上，1880–1920年間，總共增加了2700萬新移民。人數之多，不僅令政府大為頭痛而急於修改移民法令1930年以後的移民人數大減，同時新移民也帶來了很多社會問題。

但普遍文科仔就只會著墨於這些人類甚麼的、社會甚麼的，文科仔所忽視的是，國家人口急增所直接導致的是，以往的人口統計方法論全盤瓦解。基本上當你完成1910年的人口統計的時候，月曆已經要翻到去1918年了。如是者統計局最急先要處理的是人口統計的機械化。美國聯邦統計局部長發明了機器來做這件事，幾年後他自立門戶，這間公司就是現在家喻戶曉的IBM。

在第二次世界大戰前後，歐美各國其實都在差不多一樣的時間，相繼獨立地研發電腦，不只是英國用電腦來破解德國的暗號，美軍也有其電腦研究。

後來科學家開始設計出電腦之間的溝通亦即是內聯網。起初是由大學研究所之間的學術交流之用，是粒子物理學家家的玩意，後來不少其他研究所和企業之間也建立起自己的內聯網。後來美國國家科學院接手，統一了林林種種不同的網絡架構，使大家都能互相交流，那就是互聯網。

互聯網的核心是TCP/IP，SSL等的協議。確保了大家說的都是同一種語言。我們應該慶幸互聯網的建設當中沒有文科仔的參與。一旦如果有文科仔介入，互聯網就會變成飛鴿傳書，說甚麼機械太冷漠沒有溫度，IP地址的解析只在乎觀點與角度云云的。

# 圖靈機和電腦極限
文科說：不能所有東西都可以科學地看，不是所有東西都可以計算得清清楚楚。

但文科仔真的知道甚麼是「計算」嗎？哲學上分析「計算」的思想框架是圖靈機。就是說，所有的計算都不外乎是(極粗略地)輸入資料、處理器、處理結果的記錄，這三件東西。拿著這些東西，你可以做出所有的運算。

但同時有些東西不能計算(non computable)，那就是自相矛盾的東西。書中舉的例子是：

假設有一個處理器，當這個處理器偵測到現在的計算是永無止境的話，它就會自動停下，相反則繼續運行。

如果你將這個處理器和它的功能輸入到其自身，來檢測一下它自己是不是永無止境地計算，矛盾就會因此而起。

>>> 如果我(處理器)會永無止境地計下去的話，我會自動停下(？？？)

文科人看到這些資訊是，就會搶著說所以人文關懷很重要，電腦做不到的就要靠人文來彌補云云。

但你想一想，現在說是「所有的計算」。理論電腦也不能解決的事，你隨便讀個文學學位就會忽然解決得到？只有兩個可能性：

1 你不是用「計算」的方法來計算，是用魔法
2 你是白痴

所以說邏輯很重要，但邏輯是不能從學習文科而獲得。

當然這個圖靈機的停機問題(halt problem)只是一個數學證明。證明了不是「所有」東西都可以計算出來。因為數學家能夠舉出一個反證，就是上面那部會自相矛盾的處理器。換句話說，當你的處理器和它的功能是同上面一樣的話，這個處理器是廢的，不能解決問題。只要你的處理器與上面例子不同，你大可以安心計數。

# 演算法
電腦科學的精髓在於演算法。演算法決定了人類文明的進步空間。

文科仔會問，我們真的需要做事這麼快嗎？不能放慢一點，帶點溫度，帶點感情，欣賞一下過程中的美，更添一點人文雅致。

我有很多可以讓你計到下一次宇宙大爆炸都未曾計完的計算學難題。你文科仔要試一試計一計嗎？

計算之上，效率就是唯一真理。演算法就是鑽研怎樣更快的學問。最簡單的速度提升是binary search。前提是你有一本依照abc排列的電話簿。你想知道陳小明(Chan)電話，你不會由1開始逐頁揭，而是打開中間，一看不是C頁，於是你知道你可以完全不需要看之後的頁數。因為M比C大，C不可能在更後的頁數裏面。如是者你需要搜尋的範圍就由800頁變成400頁。重覆幾次相同步驟:

800->400->200->100->50->25->12->6->3->2->1

很快你就找到陳小明。

# 電腦架構
電腦的中心是處理器，除此之外就是記憶體。你要有「資料」才能得處理。就如很多文科仔會說科學方法比科學知識重要，說這些東西的人只會是地平論者。事實你必須要有相同分量的處理能力和硬知識，你要知道甚麼是fact。推論和思考方法是不能帶給你fact的。

記憶體有速度之分。早期的電腦處理器速度慢，處理不了不多資料，很多時候是100%佔用率。現在的處理器速度極快，計算的樽頸從處理器變成記憶體，就是說等了很久也未等到想要的資料，白白浪費時間。於是乎就出現了更快的記憶體叫cache，再快的叫register。一個比一個快，但一個比一個細小。

速度
RAM < L3 cache < L2 cache < L1 cache < register

容量
RAM > L3 cache > L2 cache > L1 cache > register

處理器首先會看看想要的資料有沒有在register，沒有的話就看有沒有在cache，再沒有的話就看有沒有在RAM，有的話就會從RAM調動到register。問題是RAM很慢，拖延了處理速度。如果一開始將要用到的資料要放在cache的話會快很多。買CPU的時候除了看cache容量的時候也要看cache速度。

# 軟件架構
程式語言也分幾個層次。由最底層的說起：

1 Machine Language
2 Assembly Language
3 High Level Programming Language

Machine Language就是電腦處理器真正能夠看得懂的東西，是一堆010101100110。內容就是說要對甚麼記憶體的資料作出甚麼操作，例如是加減乘除。

<Asembler> 將Assembly Language轉譯成Machine Language

Assembly Language就是人看得懂的Machine Language。例如「加」的指令不是01001，而是SUM。早期的電腦程式用這種語言來編寫。

<Compiler> 將High Level Programming Language轉譯成Assembly Language

High Level Programming Language的用家不用再去思考甚麼記憶體的。可以有更多空間去思考更複雜的運算。例如你將兩個名單的數字相加的時候，再不需要逐個記憶體來加，而只需要A名單+B名單就可以了。電腦會在背後幫你補上實際上需要的清晰明確的指令。

但現實上電腦的硬件各有不同，令到各廠牌之間的Machine Language和Assembly Language都是不同。你必須要為每一部電腦去重新編程。High Level Programming Language的好處就是你不用擔心這個問題，同一個程式可以用不同的compiler來對應不同的硬件，避免了重新編程的大工程。例如Java和C#，標榜的就是這種多平台的兼容性。

文科仔要留意的是，電腦程序的轉譯工作是全自動的。compiler的設計極為複雜，需要判斷程式員的意圖而寫出準確的Assemble Language。你不能夠有半點含糊。電腦(邏輯真理not/and/or)的世界的不容納文科的。

# 電腦科學的應用
電腦遊戲是考驗電腦的性能終極指標。因為你必須要在極短的時間來完成所有計算，才能展現給用家流暢而精美的畫面。

例如說1920*1080的畫面即200萬像素，每個像素都有10個因素影響其顏色。每秒需要產生60張畫面，你每秒就需要進行12次實時運算。為甚麼說實時，因為電腦不能預知下一秒玩家會作出甚麼行為，因此就只能夠在玩家做出舉動之後才能作出反應。電腦在0.016秒之內必須要完成工作，否則就只是垃圾。

文科工作是不需要到這麼緊湊的時間控制。例如甚麼剪片，用幾個鐘來產生一張圖，誰會去理由3小時和2小時的分別？但現實我們需要更多的是實時系統。例如航空管制、天氣予報、車流監測、網路數據分析。文科的工作和思想，反而接近零需要。

# 人工智能
這本書會帶能你最基本的Machine Learning和Deep Learning知識。但要真正明白的話，還是先去讀Linear Algebra吧。